ğŸš€ MRC Enigma System â€“ Complete GitHub Package



ğŸ“ Project Structure

```
MRC-Enigma-System/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ enigma.py
â”‚   â”œâ”€â”€ rotors.py
â”‚   â”œâ”€â”€ reflector.py
â”‚   â”œâ”€â”€ plugboard.py
â”‚   â””â”€â”€ key_manager.py
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ test_enigma.py
â”‚   â”œâ”€â”€ test_rotors.py
â”‚   â””â”€â”€ test_integration.py
â”œâ”€â”€ examples/
â”‚   â”œâ”€â”€ basic_usage.py
â”‚   â””â”€â”€ file_encryption.py
â”œâ”€â”€ docs/
â”‚   â””â”€â”€ API_REFERENCE.md
â”œâ”€â”€ requirements.txt
â”œâ”€â”€ setup.py
â”œâ”€â”€ .gitignore
â”œâ”€â”€ LICENSE
â”œâ”€â”€ README.md
â””â”€â”€ config.yaml
```

ğŸ“„ File Contents

1.	README.md

```markdown
# ğŸ§  MRC Enigma System

A modern Python implementation of the Enigma machine encryption system with enhanced security features.

## âœ¨ Features
- Historical Enigma Machine emulation
- Customizable rotor configurations
- Plugboard support for character substitution
- File encryption/decryption
- Multiple cipher modes
- Cryptographic validation

## ğŸš€ Quick Start

```bash
# Clone repository
Git clone https://github.com/yourusername/MRC-Enigma-System.git
Cd MRC-Enigma-System

# Install dependencies
Pip install -r requirements.txt

# Run example
Python examples/basic_usage.py
```

ğŸ“– Documentation

See docs/ for detailed API reference and usage examples.

ğŸ”’ Security Note

This is an educational implementation. For production-grade encryption, use established libraries like cryptography.io.

ğŸ¤ Contributing

Pull requests are welcome! Please read CONTRIBUTING.md for details.

ğŸ“„ License

MIT License â€“ see LICENSE file

```

### **2. Src/enigma.py**
```python
â€œâ€â€
Main Enigma machine implementation
MRC Enigma System v1.0
â€œâ€â€

Import string
From typing import Dict, List, Optional
From .rotors import Rotor
From .reflector import Reflector
From .plugboard import Plugboard

Class MRCEnigma:
    â€œâ€â€Modern Enigma Machine Implementationâ€â€â€
    
    Def __init__(self, config: Dict = None):
        â€œâ€â€
        Initialize Enigma machine
        
        Args:
            Config: Configuration dictionary with rotor settings, 
                   Plugboard connections, etc.
        â€œâ€â€
        Self.config = config or self.default_config()
        Self.rotors = []
        Self.reflector = None
        Self.plugboard = None
        Self.setup_machine()
        
        # Character set (A-Z)
        Self.alphabet = string.ascii_uppercase
        Self.char_to_idx = {ch: I for I, ch in enumerate(self.alphabet)}
        Self.idx_to_char = {i: ch for I, ch in enumerate(self.alphabet)}
    
    Def default_config(self) -> Dict:
        â€œâ€â€Return default Enigma configurationâ€â€â€
        Return {
            â€˜rotorsâ€™: [â€˜Iâ€™, â€˜IIâ€™, â€˜IIIâ€™],
            â€˜reflectorâ€™: â€˜Bâ€™,
            â€˜ring_settingsâ€™: [0, 0, 0],
            â€˜initial_positionsâ€™: â€˜AAAâ€™,
            â€˜plugboard_connectionsâ€™: [],
            â€˜double_stepâ€™: True
        }
    
    Def setup_machine(self):
        â€œâ€â€Configure machine componentsâ€â€â€
        # Setup rotors
        For I, rotor_type in enumerate(self.config[â€˜rotorsâ€™]):
            Rotor = Rotor(
                Rotor_type=rotor_type,
                Ring_setting=self.config[â€˜ring_settingsâ€™][i],
                Initial_position=self.config[â€˜initial_positionsâ€™][i]
            )
            Self.rotors.append(rotor)
        
        # Setup reflector
        Self.reflector = Reflector(self.config[â€˜reflectorâ€™])
        
        # Setup plugboard
        Self.plugboard = Plugboard(self.config[â€˜plugboard_connectionsâ€™])
    
    Def encrypt_char(self, char: str) -> str:
        â€œâ€â€
        Encrypt a single character
        
        Args:
            Char: Single character to encrypt
            
        Returns:
            Encrypted character
        â€œâ€â€
        If len(char) != 1 or char.upper() not in self.alphabet:
            Return char
        
        # Convert to uppercase
        Char = char.upper()
        
        # Step 1: Rotate rotors
        Self._rotate_rotors()
        
        # Step 2: Pass through plugboard (forward)
        Char = self.plugboard.map_forward(char)
        
        # Step 3: Pass through rotors (right to left)
        Char_idx = self.char_to_idx[char]
        
        # Forward through rotors (right to left)
        For rotor in reversed(self.rotors):
            Char_idx = rotor.forward(char_idx)
        
        # Step 4: Pass through reflector
        Char_idx = self.reflector.reflect(char_idx)
        
        # Step 5: Pass through rotors (left to right, inverse)
        For rotor in self.rotors:
            Char_idx = rotor.backward(char_idx)
        
        # Convert back to character
        Char = self.idx_to_char[char_idx]
        
        # Step 6: Pass through plugboard (backward)
        Char = self.plugboard.map_backward(char)
        
        Return char
    
    Def decrypt_char(self, char: str) -> str:
        â€œâ€â€
        Decrypt a single character (same as encryption process)
        â€œâ€â€
        Return self.encrypt_char(char)
    
    Def encrypt_text(self, text: str) -> str:
        â€œâ€â€
        Encrypt a string of text
        
        Args:
            Text: Plaintext to encrypt
            
        Returns:
            Ciphertext
        â€œâ€â€
        Result = []
        For char in text:
            Result.append(self.encrypt_char(char))
        Return â€˜â€™.join(result)
    
    Def decrypt_text(self, text: str) -> str:
        â€œâ€â€
        Decrypt a string of text
        
        Args:
            Text: Ciphertext to decrypt
            
        Returns:
            Plaintext
        â€œâ€â€
        # Reset machine to initial state
        Self.reset()
        Return self.encrypt_text(text)
    
    Def _rotate_rotors(self):
        â€œâ€â€Rotate rotors according to Enigma stepping rulesâ€â€â€
        # Rightmost rotor always rotates
        Rotate_next = True
        
        For I in range(len(self.rotors) â€“ 1, -1, -1):
            If rotate_next:
                # Check for double step if enabled
                If (self.config[â€˜double_stepâ€™] and I == 1 and 
                    Self.rotors[2].is_at_notch()):
                    Rotate_next = True
                Else:
                    Rotate_next = self.rotors[i].is_at_notch()
                
                Self.rotors[i].rotate()
            Else:
                Break
    
    Def reset(self):
        â€œâ€â€Reset machine to initial stateâ€â€â€
        For rotor in self.rotors:
            Rotor.reset()
    
    Def get_current_state(self) -> Dict:
        â€œâ€â€Return current machine stateâ€â€â€
        Return {
            â€˜rotor_positionsâ€™: [rotor.position for rotor in self.rotors],
            â€˜ring_settingsâ€™: [rotor.ring_setting for rotor in self.rotors],
            â€˜plugboardâ€™: self.plugboard.connections
        }

# Convenience functions
Def create_enigma_from_config(config_file: str = â€˜config.yamlâ€™):
    â€œâ€â€Factory function to create Enigma from config fileâ€â€â€
    Import yaml
    With open(config_file, â€˜râ€™) as f:
        Config = yaml.safe_load(f)
    Return MRCEnigma(config)

Def generate_random_config():
    â€œâ€â€Generate random Enigma configurationâ€â€â€
    Import random
    Import string
    
    Config = {
        â€˜rotorsâ€™: random.sample([â€˜Iâ€™, â€˜IIâ€™, â€˜IIIâ€™, â€˜IVâ€™, â€˜Vâ€™], 3),
        â€˜reflectorâ€™: random.choice([â€˜Aâ€™, â€˜Bâ€™, â€˜Câ€™]),
        â€˜ring_settingsâ€™: [random.randint(0, 25) for _ in range(3)],
        â€˜initial_positionsâ€™: â€˜â€™.join(
            Random.choice(string.ascii_uppercase) for _ in range(3)
        ),
        â€˜plugboard_connectionsâ€™: []
    }
    
    # Generate random plugboard connections
    Alphabet = list(string.ascii_uppercase)
    Random.shuffle(alphabet)
    For I in range(0, 10, 2):  # Up to 10 connections
        Config[â€˜plugboard_connectionsâ€™].append(
            (alphabet[i], alphabet[i+1])
        )
    
    Return config
```

2.	Src/rotors.py

```python
â€œâ€â€
Rotor implementation for MRC Enigma System
â€œâ€â€

Class Rotor:
    â€œâ€â€Enigma Machine Rotorâ€â€â€
    
    # Historical Enigma rotor wirings
    ROTOR_WIRINGS = {
        â€˜Iâ€™:   â€˜EKMFLGDQVZNTOWYHXUSPAIBRCJâ€™,
        â€˜IIâ€™:  â€˜AJDKSIRUXBLHWTMCQGZNPYFVOEâ€™,
        â€˜IIIâ€™: â€˜BDFHJLCPRTXVZNYEIWGAKMUSQOâ€™,
        â€˜IVâ€™:  â€˜ESOVPZJAYQUIRHXLNFTGKDCMWBâ€™,
        â€˜Vâ€™:   â€˜VZBRGITYUPSDNHLXAWMJQOFECKâ€™
    }
    
    # Notch positions (where rotor causes next rotor to step)
    ROTOR_NOTCHES = {
        â€˜Iâ€™: â€˜Qâ€™,
        â€˜IIâ€™: â€˜Eâ€™,
        â€˜IIIâ€™: â€˜Vâ€™,
        â€˜IVâ€™: â€˜Jâ€™,
        â€˜Vâ€™: â€˜Zâ€™
    }
    
    Def __init__(self, rotor_type: str = â€˜Iâ€™, 
                 Ring_setting: int = 0, 
                 Initial_position: str = â€˜Aâ€™):
        â€œâ€â€
        Initialize rotor
        
        Args:
            Rotor_type: Rotor type (I, II, III, IV, V)
            Ring_setting: Ring setting offset (0-25)
            Initial_position: Starting position (A-Z)
        â€œâ€â€
        Self.rotor_type = rotor_type
        Self.wiring = self.ROTOR_WIRINGS[rotor_type]
        Self.notch = self.ROTOR_NOTCHES[rotor_type]
        
        # Convert initial position to index (A=0, B=1, etc.)
        Self.initial_position = ord(initial_position.upper()) â€“ 65
        Self.position = self.initial_position
        
        Self.ring_setting = ring_setting
        
        # Create forward and backward mapping
        Self._create_mappings()
    
    Def _create_mappings(self):
        â€œâ€â€Create forward and backward character mappingsâ€â€â€
        Alphabet = â€˜ABCDEFGHIJKLMNOPQRSTUVWXYZâ€™
        
        # Forward mapping (right to left)
        Self.forward_map = {}
        For I, char in enumerate(alphabet):
            # Apply ring setting and position offset
            Offset_idx = (I + self.position â€“ self.ring_setting) % 26
            Mapped_char = self.wiring[offset_idx]
            # Apply reverse offset
            Final_idx = (ord(mapped_char) â€“ 65 â€“ self.position + self.ring_setting) % 26
            Self.forward_map[i] = final_idx
        
        # Backward mapping (left to right, inverse)
        Self.backward_map = {}
        For I, char in enumerate(self.wiring):
            Original_idx = (ord(char) â€“ 65 + self.position â€“ self.ring_setting) % 26
            Final_idx = (I â€“ self.position + self.ring_setting) % 26
            Self.backward_map[original_idx] = final_idx
    
    Def forward(self, char_idx: int) -> int:
        â€œâ€â€
        Map character through rotor (right to left)
        
        Args:
            Char_idx: Input character index (0-25)
            
        Returns:
            Mapped character index
        â€œâ€â€
        Return self.forward_map[char_idx]
    
    Def backward(self, char_idx: int) -> int:
        â€œâ€â€
        Map character through rotor in reverse (left to right)
        
        Args:
            Char_idx: Input character index (0-25)
            
        Returns:
            Mapped character index
        â€œâ€â€
        Return self.backward_map[char_idx]
    
    Def rotate(self):
        â€œâ€â€Rotate rotor by one positionâ€â€â€
        Self.position = (self.position + 1) % 26
        Self._create_mappings()
    
    Def set_position(self, position: str):
        â€œâ€â€Set rotor to specific positionâ€â€â€
        Self.position = ord(position.upper()) â€“ 65
        Self._create_mappings()
    
    Def is_at_notch(self) -> bool:
        â€œâ€â€Check if rotor is at notch positionâ€â€â€
        Return self.position == (ord(self.notch) â€“ 65)
    
    Def reset(self):
        â€œâ€â€Reset rotor to initial positionâ€â€â€
        Self.position = self.initial_position
        Self._create_mappings()
    
    Def __str__(self):
        Return (fâ€Rotor {self.rotor_type} â€œ
                Fâ€(Pos: {chr(self.position + 65)}, â€œ
                Fâ€Ring: {self.ring_setting})â€)
```

3.	Src/reflector.py

```python
â€œâ€â€
Reflector implementation for MRC Enigma System
â€œâ€â€

Class Reflector:
    â€œâ€â€Enigma Machine Reflectorâ€â€â€
    
    # Historical reflector wirings
    REFLECTOR_WIRINGS = {
        â€˜Aâ€™: â€˜EJMZALYXVBWFCRQUONTSPIKHGDâ€™,
        â€˜Bâ€™: â€˜YRUHQSLDPXNGOKMIEBFZCWVJATâ€™,
        â€˜Câ€™: â€˜FVPJIAOYEDRZXWGCTKUQSBNMHLâ€™
    }
    
    Def __init__(self, reflector_type: str = â€˜Bâ€™):
        â€œâ€â€
        Initialize reflector
        
        Args:
            Reflector_type: Reflector type (A, B, C)
        â€œâ€â€
        Self.reflector_type = reflector_type
        Self.wiring = self.REFLECTOR_WIRINGS[reflector_type]
        Self._create_mapping()
    
    Def _create_mapping(self):
        â€œâ€â€Create reflector mappingâ€â€â€
        Self.mapping = {}
        For I, char in enumerate(self.wiring):
            Self.mapping[i] = ord(char) â€“ 65
    
    Def reflect(self, char_idx: int) -> int:
        â€œâ€â€
        Reflect character through reflector
        
        Args:
            Char_idx: Input character index (0-25)
            
        Returns:
            Reflected character index
        â€œâ€â€
        Return self.mapping[char_idx]
    
    Def __str__(self):
        Return fâ€Reflector {self.reflector_type}â€
```

4.	Src/plugboard.py

```python
â€œâ€â€
Plugboard implementation for MRC Enigma System
â€œâ€â€

Class Plugboard:
    â€œâ€â€Enigma Machine Plugboardâ€â€â€
    
    Def __init__(self, connections: list = None):
        â€œâ€â€
        Initialize plugboard
        
        Args:
            Connections: List of character pairs to swap [(A,B), (C,D), â€¦]
        â€œâ€â€
        Self.connections = connections or []
        Self._create_mappings()
    
    Def _create_mappings(self):
        â€œâ€â€Create plugboard forward and backward mappingsâ€â€â€
        Self.forward_map = {}
        Self.backward_map = {}
        
        # Start with identity mapping
        For I in range(26):
            Self.forward_map[i] = i
            Self.backward_map[i] = i
        
        # Apply plugboard connections
        For a, b in self.connections:
            Idx_a = ord(a.upper()) â€“ 65
            Idx_b = ord(b.upper()) â€“ 65
            Self.forward_map[idx_a] = idx_b
            Self.forward_map[idx_b] = idx_a
            Self.backward_map[idx_a] = idx_b
            Self.backward_map[idx_b] = idx_a
    
    Def map_forward(self, char: str) -> str:
        â€œâ€â€
        Map character through plugboard (forward direction)
        
        Args:
            Char: Single character
            
        Returns:
            Mapped character
        â€œâ€â€
        Idx = ord(char.upper()) â€“ 65
        Mapped_idx = self.forward_map.get(idx, idx)
        Return chr(mapped_idx + 65)
    
    Def map_backward(self, char: str) -> str:
        â€œâ€â€
        Map character through plugboard (backward direction)
        
        Args:
            Char: Single character
            
        Returns:
            Mapped character
        â€œâ€â€
        Idx = ord(char.upper()) â€“ 65
        Mapped_idx = self.backward_map.get(idx, idx)
        Return chr(mapped_idx + 65)
    
    Def add_connection(self, pair: tuple):
        â€œâ€â€Add a new plugboard connectionâ€â€â€
        If len(self.connections) < 10:  # Historical limit
            Self.connections.append(pair)
            Self._create_mappings()
    
    Def clear_connections(self):
        â€œâ€â€Clear all plugboard connectionsâ€â€â€
        Self.connections = []
        Self._create_mappings()
    
    Def __str__(self):
        Return fâ€Plugboard ({len(self.connections)} connections)â€
```

5.	Src/key_manager.py

```python
â€œâ€â€
Key management for MRC Enigma System
â€œâ€â€

Import json
Import yaml
From datetime import datetime
From typing import Dict, List, Optional

Class KeyManager:
    â€œâ€â€Manage encryption keys and configurationsâ€â€â€
    
    Def __init__(self):
        Self.keys = {}
        Self.current_key_id = None
    
    Def generate_key(self, 
                     Name: str = None,
                     Description: str = â€œâ€) -> str:
        â€œâ€â€
        Generate new encryption key
        
        Args:
            Name: Key name
            Description: Key description
            
        Returns:
            Key ID
        â€œâ€â€
        From .enigma import generate_random_config
        
        Key_id = fâ€key_{datetime.now().strftime(â€˜%Y%m%d_%H%M%Sâ€™)}â€
        
        Config = generate_random_config()
        
        Self.keys[key_id] = {
            â€˜idâ€™: key_id,
            â€˜nameâ€™: name or fâ€Key {key_id}â€,
            â€˜descriptionâ€™: description,
            â€˜configâ€™: config,
            â€˜createdâ€™: datetime.now().isoformat(),
            â€˜last_usedâ€™: None
        }
        
        Self.current_key_id = key_id
        Return key_id
    
    Def save_keys(self, filename: str = â€˜keys.jsonâ€™):
        â€œâ€â€Save keys to fileâ€â€â€
        With open(filename, â€˜wâ€™) as f:
            Json.dump(self.keys, f, indent=2)
    
    Def load_keys(self, filename: str = â€˜keys.jsonâ€™):
        â€œâ€â€Load keys from fileâ€â€â€
        Try:
            With open(filename, â€˜râ€™) as f:
                Self.keys = json.load(f)
        Except FileNotFoundError:
            Self.keys = {}
    
    Def export_config(self, key_id: str, format: str = â€˜yamlâ€™) -> str:
        â€œâ€â€
        Export key configuration
        
        Args:
            Key_id: Key identifier
            Format: Export format (yaml, json)
            
        Returns:
            Configuration as string
        â€œâ€â€
        If key_id not in self.keys:
            Raise ValueError(fâ€Key {key_id} not foundâ€)
        
        Config = self.keys[key_id][â€˜configâ€™]
        
        If format.lower() == â€˜yamlâ€™:
            Return yaml.dump(config, default_flow_style=False)
        Elif format.lower() == â€˜jsonâ€™:
            Return json.dumps(config, indent=2)
        Else:
            Raise ValueError(fâ€Unsupported format: {format}â€)
    
    Def list_keys(self) -> List[Dict]:
        â€œâ€â€List all available keysâ€â€â€
        Return list(self.keys.values())
    
    Def delete_key(self, key_id: str):
        â€œâ€â€Delete keyâ€â€â€
        If key_id in self.keys:
            Del self.keys[key_id]
            If self.current_key_id == key_id:
                Self.current_key_id = None
    
    Def get_key_config(self, key_id: str) -> Dict:
        â€œâ€â€Get configuration for specific keyâ€â€â€
        If key_id not in self.keys:
            Raise ValueError(fâ€Key {key_id} not foundâ€)
        
        Self.keys[key_id][â€˜last_usedâ€™] = datetime.now().isoformat()
        Return self.keys[key_id][â€˜configâ€™]

# Singleton instance
Key_manager = KeyManager()
```

6.	Examples/basic_usage.py

```python
#!/usr/bin/env python3
â€œâ€â€
Basic usage example for MRC Enigma System
â€œâ€â€

Import sys
Import os
Sys.path.insert(0, os.path.join(os.path.dirname(__file__), â€˜..â€™))

From src.enigma import MRCEnigma, create_enigma_from_config
From src.key_manager import key_manager

Def basic_encryption():
    â€œâ€â€Demonstrate basic encryption/decryptionâ€â€â€
    Print(â€œ=â€ * 50)
    Print(â€œMRC Enigma System â€“ Basic Demoâ€)
    Print(â€œ=â€ * 50)
    
    # Generate a random configuration
    Print(â€œ\n1. Generating random configurationâ€¦â€)
    Key_id = key_manager.generate_key(
        Name=â€Demo Keyâ€,
        Description=â€Example key for demonstrationâ€
    )
    Config = key_manager.get_key_config(key_id)
    
    # Create Enigma machine
    Print(â€œ\n2. Creating Enigma machineâ€¦â€)
    Enigma = MRCEnigma(config)
    
    # Display configuration
    Print(â€œ\n3. Machine Configuration:â€)
    Print(fâ€   Rotors: {config[â€˜rotorsâ€™]}â€)
    Print(fâ€   Reflector: {config[â€˜reflectorâ€™]}â€)
    Print(fâ€   Initial positions: {config[â€˜initial_positionsâ€™]}â€)
    Print(fâ€   Plugboard connections: {config[â€˜plugboard_connectionsâ€™]}â€)
    
    # Test encryption
    Print(â€œ\n4. Testing encryptionâ€¦â€)
    Plaintext = â€œHELLOWORLDâ€
    Print(fâ€   Plaintext: {plaintext}â€)
    
    Ciphertext = enigma.encrypt_text(plaintext)
    Print(fâ€   Ciphertext: {ciphertext}â€)
    
    # Reset and decrypt
    Enigma.reset()
    Decrypted = enigma.decrypt_text(ciphertext)
    Print(fâ€   Decrypted: {decrypted}â€)
    
    # Verify
    If plaintext == decrypted:
        Print(â€œ\nâœ… Encryption/Decryption successful!â€)
    Else:
        Print(â€œ\nâŒ Error in encryption/decryption!â€)
    
    # Save key
   






